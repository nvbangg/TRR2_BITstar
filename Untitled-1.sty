 \documentclass[12pt,a4paper,openany,oneside]{report}
\usepackage[utf8]{vietnam}
\usepackage{amsmath, amsthm, amssymb,amsxtra,latexsym,amscd,graphpap,makeidx}
\usepackage{pgf,tikz}
\usepackage{mathrsfs}
\usetikzlibrary{arrows}
\usepackage{float}
 \usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{array,tabularx,longtable,multicol,indentfirst,fancyhdr}%
\usepackage[mathscr]{eucal}
\usepackage[top=3.5cm, bottom=3.0cm, left=3.5cm, right=2cm] {geometry}
\usepackage{fancybox}
\usepackage{media9}
%==================================  
\newtheorem{dl}{Định lý}[section]
\newtheorem{dn}[dl]{Định nghĩa} 
\newtheorem{bt}[dl]{Bài toán} 
\newtheorem{btp}[dl]{Bài tập} 
\newtheorem{bta}[dl]{Bài} 
\newtheorem{bai}[dl]{Bài}
\newtheorem{tc}[dl]{Tính chất} 
\newtheorem{md}[dl]{Mệnh đề} 
\newtheorem{bd}[dl]{Bổ đề} 
\newtheorem{hq}[dl]{Hệ quả} 
\newtheorem{nx}[dl]{Nhận xét} 
\newtheorem{cy}[dl]{Chú ý} 
\newtheorem{vd}[dl]{Ví dụ} 
\usepackage{hyperref}
\renewcommand{\chaptername}{Mục \chaptername}
\renewcommand\bibname{Tài liệu tham khảo}
%.....................................

\newcommand{\bpr}{\begin{proof}}
\newcommand{\epr}{\end{proof}}

 % package content table



%-----------------------------------------------
\def\en{\enskip}
\def\n{\noindent}
\def\m{\medskip}
\def\en{\enskip}
\def\m{\medskip}
\def\n{\noindent}
\def\Re{\mbox{Re }}
\def\Im{\mbox{Im }}
\def\hcm{\hfill $\square$\\}
\def\imotn{i = 1, 2, \ldots, n}
\def\ii{\item}


\def\N{\mathbb{N}}
\def\Z{\mathbb{Z}}
\def\R{\mathbb{R}}
\def\Q{\mathbb{Q}}
\def\C{\mathscr{C}}  
\def\K{\mathbb{K}}  
\def\F{\mathbb{F}}  
\def\L{\mathbb{L}} 
\DeclareMathOperator{\ord}{ord}

\allowdisplaybreaks
\newenvironment{giai}{\noindent{\em \textit{Giải}. }}{\hfill $\square$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
 
\makeatletter 
\renewcommand{\ps@plain}{
    \renewcommand{\@oddhead}{\hfil{\thepage}\hfil}
    \renewcommand{\@evenhead}{\@oddhead}
    \renewcommand{\@oddfoot}{\empty}
    \renewcommand{\@evenfoot}{\@oddfoot}   }
\makeatother
\pagestyle{fancy}
\fancyhf{}
\rhead{}
\chead{\normalsize  \thepage}
\lhead{\itshape {\nouppercase{}}}
\renewcommand{\headrulewidth}{0pt}





\begin{document}
	
	%Cô mới thêm vào đoạn này
	%========================================
	\pagestyle{fancy}
	\fancyhf{}
	\fancyhead[L]{Bài tập lớn toán rời rạc 2} % Di chuyển header về bên trái
	\renewcommand{\headrulewidth}{0.4pt} % Gạch dưới header
	\fancyfoot[L]{Nhóm 3 BTL TRR2 }
	\fancyfoot[R]{\roman{page}} % Số trang theo chữ số La mã ở bên phải của footer
	\renewcommand{\footrulewidth}{0.4pt} % Dòng kẻ trên footer
	
	\pagenumbering{gobble}
	
	%==============================================
%\pagenumbering{roman}




\newgeometry{top=2.0cm,bottom=3.0cm,left=3.0cm,right=2.8cm}
\setlength{\fboxrule}{1.5pt}
\thisfancypage{\setlength{\fboxsep}{10pt}\setlength{\shadowsize}{0pt}\doublebox}{}

\fontsize{14pt}{14pt}\selectfont \baselineskip 0.65cm
\thispagestyle{empty}
\begin{center}
	{HỌC VIỆN CÔNG NGHỆ BƯU CHÍNH VIỄN THÔNG}\\
	\textbf{\MakeUppercase{KHOA CÔNG NGHỆ THÔNG TIN I}}\\
	\centerline{--------------------o0o--------------------}  
\end{center}


\begin{figure}[H]
	\begin{center}
		\includegraphics[width=6cm]{./logo}
	\end{center}
\end{figure} 



\vspace{0.5cm}
\begin{center}
	\textbf{\MakeUppercase{\LARGE \bf Bài tập lớn toán rời rạc 2}}\\ 
\end{center} 

\vspace{1cm}
\begin{center}
\textbf{Đề tài:}
	\textbf{\MakeUppercase{ \bf ``Thuật toán Batch-Informed RRT* (BIT*)''}}\\ 
\end{center} 
\vspace{2cm}


\begin{tabular}{ll}
	{\textbf{\large{Giảng Viên Hướng Dẫn: }}} & {\large TS. Nguyễn Kiều Linh}\\
	{\textbf{\large{Nhóm thực hiện:}}}  & {\large Nhóm 3} \\
	{\textbf{\large{Lớp:}}}   & {\large Nhóm 14 Toán rời rạc 2}\\
	{\textbf{\large{Hệ đào tạo:}}}   & {\large Đại học chính quy}
\end{tabular}


\vfill
\begin{center}
	{{\bf Hà Nội, 05/2025}}
\end{center}

\newpage
%===========table============
{\fontsize{20}{24}\selectfont \textbf{Bảng phân công công việc}} % Tiêu đề cỡ chữ 20pt
\vspace{1em} % Khoảng cách giữa tiêu đề và bảng
\begin{center}
\begin{tabular}{|c|l|c|l|}
\hline
\textbf{STT} & \textbf{Họ và tên} & \textbf{Mã sinh viên} & \textbf{Công việc} \\
\hline
1 & Nguyễn Đức Toàn & B23DCCN831 & Code báo cáo \\
\hline
2 & Trần Thu Thiên & B23DCCN785 & Làm slide, thuyết trình \\
\hline
3 & Hoàng Xuân Vinh & B23DCCN929 & Code báo cáo \\
\hline
4 & Nguyễn Thị Uyên & B23DCCN912 & Soạn nội dung \\
\hline
5 & Trần Đăng Dương & B23DCCN227 & Soạn nội dung \\
\hline
6 & Nguyễn Văn Bằng & B23DCCN067 & Code thuật toán, soạn nội dung \\
\hline
7 & Đại Đức Hiếu & B23DCCN297 & Code báo cáo \\
\hline
8 & Nguyễn Quế Hoàng & B23DCCN339 & Soạn nội dung \\
\hline
\end{tabular}
\end{center}
%Cô mới thêm vào đoạn này
%========================================


%%%%%%%%%%%%%%%
\newgeometry{top=2.5cm,bottom=2cm,left=3cm,right=2cm} 
\thispagestyle{empty}
\begin{center}
	{\textbf{\Large{NHẬN XÉT CỦA GIẢNG VIÊN HƯỚNG DẪN}}}
\end{center}

\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill

\vspace{1cm}

{\textbf{\large{Điểm: }}} \hspace{1.0cm}\textbf{( Bằng chữ:}  \hspace{2.5cm}\textbf{)}  

\begin{flushright}
	Hà Nội, ngày \hspace{0.75cm} tháng \hspace{0.75cm} năm 20...\hspace{0.75cm}
	
	{\textbf{\large{Giảng viên hướng dẫn }}} \hspace{1cm} \textcolor{white}{.}
\end{flushright}



\newgeometry{top=2.5cm,bottom=2cm,left=3cm,right=2cm} 
\thispagestyle{empty}
\begin{center}
	{\textbf{\Large{NHẬN XÉT CỦA GIẢNG VIÊN PHẢN BIỆN}}}
\end{center}

\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill \vspace{0.25cm} \par
\dotfill

\vspace{1cm}

{\textbf{\large{Điểm: }}} \hspace{1.0cm}\textbf{( Bằng chữ:}  \hspace{2.5cm}\textbf{)}  

\begin{flushright}
	Hà Nội, ngày \hspace{0.75cm} tháng \hspace{0.75cm} năm 20...\hspace{0.75cm}
	
	{\textbf{\large{Giảng viên phản biện }}} \hspace{1cm} \textcolor{white}{.}
\end{flushright}

%==============================================


\restoregeometry
\pagestyle{fancy}
\pagenumbering{roman}
\fontsize{13pt}{13pt}\selectfont \baselineskip 0.75cm 

\newpage
\thispagestyle{empty}
%\thispagestyle{fancy}
%\pagenumbering{roman}
%\vspace*{-2.5cm} % Thay đổi giá trị để điều chỉnh khoảng cách
% Tạo mục lục tự động
%\addcontentsline{toc}{chapter}{Mục lục}
\tableofcontents





%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%





 
\newpage
\pagenumbering{arabic} 
\pagestyle{fancy} 

\chapter*{Mở đầu}
\addcontentsline{toc}{chapter}{\vspace*{-8pt}  Mở đầu} 


Bài toán lập kế hoạch đường đi (path planning) là một bài toán tìm kiếm
một chuỗi các cấu hình hợp lệ để di chuyển một đối tượng từ một trạng thái
bắt đầu (source/start configuration S hoặc \( x_{\text{init}} \)) đến một trạng thái đích
(destination/goal configuration G hoặc \( x_{\text{goal}} \) hoặc goal region G(\( x_{\text{goal}} \))).
Một cách cụ thể hơn, bài toán lập kế hoạch đường đi là tính toán một
đường đi liên tục tối ưu kết nối trạng thái bắt đầu S và trạng thái đích G,
đồng thời tránh va chạm với các chướng ngại vật đã biết trong không gian
trạng thái tự do \( X_{\text{free}} \)
Bài toán lập kế hoạch tối ưu được định nghĩa là việc tìm kiếm đường đi
tối thiểu hóa một hàm chi phí (c(σ) hoặc s(σ)) trên đường đi đó, trong số
tất cả các đường đi hợp lệ. Hàm chi phí thường là chiều dài của đường đi đã
đi, nhưng cũng có thể là các tiêu chí khác như thời gian thực hiện hoặc năng
lượng tiêu thụ.




Trong đề tài của phần này chúng em sẽ trình bày về thuật toán Batch-Informed RRT* (BIT*) nhằm giải quyết bài toán trên

Nội dung gồm các phần sau :

\textbf{Mục 1: Giới thiệu:}
Giới thiệu qua về Bài toán lập kế hoạch chuyển động và tình hình của một số thuật toán điển hình khác. Giới thiệu BIT* và chỉ ra điểm đặc biệt của BIT*. 

\textbf{Mục 2: Nền tảng chuẩn bị :}
 Trình bày các kiến thức nền tảng và kỹ năng cần thiết cho việc nghiên cứu và phát triển các thuật toán lập kế hoạch chuyển động.


\textbf{Mục 3: Thuật toán BIT*:}
Giới thiệu ý tưởng, giải thích và trình bày thuật toán. Đồng thời nêu mối quan hệ với các thuật toán khác


\textbf{Mục 4: Các mã giả code, kèm link code c++ và demo }


\textbf{Mục 5: So sánh và đánh giá :}
Dựa trên kết quả thực nghiệm, có thể rút ra các so sánh giữa các thuật toán, đồng thời nêu đánh giá

\textbf{Mục 6: Ứng dụng:}
Nêu ứng dụng của thuật toán BIT* trong các vấn đề được đặt ra.
% ===================================================


\chapter{Giới thiệu}

\section*{I. Giới thiệu về bài toán lập kế hoạch chuyển động}






\section*{Mục tiêu}

Bài toán lập kế hoạch đường đi (path planning) là một vấn đề cốt lõi trong robot, trí tuệ nhân tạo và nhiều ứng dụng thực tiễn. Mục tiêu là tìm một đường đi liên tục từ trạng thái bắt đầu đến trạng thái đích, tránh va chạm với chướng ngại vật trong không gian trạng thái tự do và tối ưu hóa hàm chi phí, chẳng hạn như độ dài đường đi, thời gian hoặc năng lượng tiêu thụ. 


\section*{Đầu vào:}

    \textbf{Không gian cấu hình (configuration space):} Biểu diễn tất cả trạng thái hợp lệ của robot.
    
     \textbf{Trạng thái bắt đầu và kết thúc.}
     
     \textbf{Tập chướng ngại vật:} Các vùng mà robot không được đi vào.


\section*{Đầu ra:}

Một đường đi khả thi (có thể tối ưu hoặc không), đảm bảo tránh va chạm và có thể thực thi bởi robot.

\section*{II. Các phương pháp giải điển hình}

\section*{A. Thuật toán lập kế hoạch dựa trên ô (Grid-based)}

 \textbf Ví dụ: 
 \textbf {A*, Dijkstra}

 \textbf {Ý tưởng}: Chia không gian thành các ô nhỏ và tìm đường như trên bản đồ.

 \textbf {Ưu điểm:}: Dễ hiện thực, tìm được đường tối ưu.

 \textbf {Nhược điểm: }: Không hiệu quả cho không gian lớn hoặc nhiều bậc tự do (high-dimensional C-space).

\section*{B. Thuật toán dựa trên mẫu (Sampling-based)}
 \textbf {Đây là nhóm thuật toán hiệu quả cho không gian cấu hình lớn và phức tạp.}





\begin{table}[H]




\begin{tabular}{|>{\bfseries}m{5cm}|m{9cm}|}
\hline


\textbf{Thuật toán} & \textbf{Đặc điểm} \\
\hline
PRM (Probabilistic Roadmap) & Tiền xử lý tạo đồ thị toàn cục → thích hợp cho môi trường tĩnh. \\
\hline
RRT (Rapidly-Exploring Random Tree) & Phát triển cây từ điểm bắt đầu, rất nhanh nhưng không tối ưu. \\
\hline
RRT* & Phiên bản cải tiến của RRT, đảm bảo hội tụ về lời giải tối ưu theo thời gian. \\
\hline
BIT* & Kết hợp RRT* và A*, dùng heuristic để hướng dẫn tìm kiếm → hội tụ nhanh hơn. \\
\hline
FMT* (Fast Marching Tree) & Duyệt theo front giống A*, nhanh và hiệu quả với nhiều ràng buộc động học. \\
\hline
\end{tabular}
\end{table}

\section*{C.Thuật toán dựa trên quy hoạch toán học (Optimization-based)}

\textbf Ví dụ: \textbf {CHOMP, TrajOpt, STOMP}

\textbf {Ý tưởng:} Tối ưu hóa quỹ đạo ban đầu để giảm va chạm và chi phí

\textbf {Ưu điểm: }Đường đi mượt và khả thi động học.

\textbf {Nhược điểm: }Dễ mắc kẹt ở cực trị cục bộ.

\section*{III. Giới thiệu thuật toán BIT*}

\textbf {BIT*} là một thuật toán lập kế hoạch chuyển động hiện đại, thuộc nhóm \textbf {sampling-based} (dựa trên lấy mẫu), được đề xuất để \textbf {kết hợp ưu điểm của hai hướng tiếp cận mạnh nhất hiện nay:}

\textbf Từ \textbf {RRT*}: có khả năng mở rộng cây trong không gian cấu hình và hội tụ về đường đi tối ưu theo thời gian.

\textbf Từ \textbf {A*}: sử dụng thông tin heuristic để dẫn hướng quá trình tìm kiếm một cách hiệu quả.

\textbf {Điểm đặc biệt của BIT*}

% bảng
\begin{table}[h]
\centering

\renewcommand{\arraystretch}{1.5} % tăng khoảng cách dòng trong bảng
\begin{tabular}{|>{\raggedright\arraybackslash}p{5.2cm}|>{\raggedright\arraybackslash}p{8.2cm}|}
\hline
\textbf{Đặc điểm} & \textbf{Mô tả} \\
\hline
\textbf{Batch Sampling (Lấy mẫu theo lô)} & 
Thay vì lấy từng điểm một như RRT*, BIT* lấy mẫu theo từng lô $\rightarrow$ tăng hiệu quả và kiểm soát tốt hơn việc mở rộng. \\
\hline
\textbf{Sử dụng heuristic như A*} & 
BIT* đánh giá chi phí tiềm năng $f = g + h$, trong đó: \newline
– $g$: chi phí thực đến một đỉnh trong cây \newline
– $h$: ước lượng chi phí còn lại đến đích \newline
$\Rightarrow$ giúp cây mở rộng theo hướng "thông minh", tránh lan tỏa mù mờ như RRT. \\
\hline
\textbf{Cấu trúc hàng đợi ưu tiên} & 
Cạnh và đỉnh được mở rộng theo thứ tự ưu tiên thấp nhất về chi phí dự kiến (giống A*) $\Rightarrow$ tìm được đường ngắn hơn nhanh hơn. \\
\hline
\textbf{Chỉ mở rộng những phần có tiềm năng cải thiện lời giải} & 
BIT* chỉ xem xét những điểm có tổng chi phí nhỏ hơn lời giải tốt nhất hiện tại $c_{best}$, giúp loại bỏ các nhánh không hiệu quả. \\
\hline
\textbf{Hội tụ nhanh đến đường đi tối ưu} & 
Nhờ những cơ chế trên, BIT* thường tìm được lời giải ban đầu nhanh, rồi dần cải thiện về tối ưu giống RRT* nhưng nhanh hơn đáng kể. \\
\hline
\end{tabular}
\end{table}


\chapter{Nền tảng chuẩn bị }

Mục này trình bày các kiến thức nền tảng và kỹ năng cần thiết cho việc nghiên cứu và phát triển các thuật toán lập kế hoạch chuyển động. Nội dung được chia thành năm phần chính: toán học nền tảng, kỹ năng lập trình, cấu trúc dữ liệu và thuật toán, cũng như các kiến thức bổ sung nâng cao có thể áp dụng trong thực tế. Mỗi phần cung cấp cơ sở vững chắc giúp người học hiểu rõ nguyên lý hoạt động, khả năng triển khai và tối ưu hóa thuật toán trong môi trường robot phức tạp.

\section*{1. Các định nghĩa và ký hiệu cơ bản}
\begin{itemize}
  \item Không gian trạng thái ($X$): Là tập hợp tất cả các cấu hình có thể có của robot hoặc hệ thống, thường là một tập con của $\mathbb{R}^d$, trong đó $d$ là số chiều của không gian.
  
  \item Không gian chướng ngại vật ($X_{\text{obs}}$): Vùng không gian bị chiếm bởi các chướng ngại vật.
  
  \item Không gian tự do ($X_{\text{free}}$): Phần không gian mà robot có thể di chuyển mà không va chạm, được tính bằng $X_{\text{free}} = X \setminus X_{\text{obs}}$.
  
  \item Trạng thái bắt đầu ($x_{\text{start}}$): Cấu hình ban đầu của robot, $x_{\text{start}} \in X_{\text{free}}$.
  
  \item Trạng thái đích ($x_{\text{goal}}$): Cấu hình mà robot cần đạt tới, $x_{\text{goal}} \in X_{\text{free}}$.
  
  \item Đường đi ($\sigma$): Một chuỗi liên tục các trạng thái kết nối từ trạng thái bắt đầu và trạng thái đích. Một đường đi khả thi là một đường đi không có va chạm và thỏa mãn các điều kiện bắt đầu và kết thúc.
  
  \item Hàm chi phí ($c(\sigma)$): Một hàm biểu thị chi phí của việc đi theo đường đi. Chi phí này thường là khoảng cách Euclid giữa hai điểm không có chướng ngại vật trên đường đi, hoặc vô cùng nếu có va chạm.
\end{itemize}


 \section*{2. Bán kính kết nối RGG}

Bán kính kết nối RGG, ký hiệu là $r$, xác định khoảng cách tối đa mà hai điểm mẫu được xem xét để kết nối với nhau. Việc lựa chọn bán kính này ảnh hưởng lớn đến tính chất của đồ thị được tạo ra (ví dụ: mật độ kết nối) và khả năng hội tụ của thuật toán đến lời giải tối ưu, cần thiết để đảm bảo tính tối ưu tiệm cận giảm khi số lượng mẫu tăng lên.

\textbf{Công thức:}
\[
r = \gamma \left( \frac{\log q}{q} \right)^{1/d}
\]

\textbf{Trong đó:}
\begin{itemize}
  \item $\gamma$: Một hằng số điều chỉnh. Giá trị của $\gamma$ phụ thuộc vào đặc tính của không gian trạng thái và hàm chi phí.
  
  \item $q$: Tổng số điểm đang được xem xét (bao gồm các đỉnh trong cây $V$ và các mẫu chưa kết nối $X_{\text{unconn}}$).
  \[
  q = |V| + |X_{\text{sample}}|
  \]
  
  \item $d$: Số chiều của không gian trạng thái.
\end{itemize}

Công thức này cho thấy bán kính $r$ giảm khi số lượng điểm $q$ tăng lên. Điều này đảm bảo rằng khi có nhiều mẫu hơn, thuật toán chỉ cần xem xét các kết nối trong một vùng lân cận nhỏ hơn, giúp giảm chi phí tính toán cho việc kiểm tra va chạm và tìm kiếm lân cận.


\section*{3. Hàm Heuristic}

Hàm heuristic ($h(x)$) cung cấp ước lượng chi phí từ một trạng thái $x$ hiện tại đến trạng thái đích $x_{\text{goal}}$. Trong BIT$^*$, heuristic được sử dụng để định hướng quá trình tìm kiếm, ưu tiên mở rộng các đỉnh và xem xét các cạnh có tiềm năng nằm trên đường đi tối ưu.

\textbf{Công thức:} Hàm heuristic thường là khoảng cách Euclid giữa điểm hiện tại và điểm đích.
\[
h(n) = \sqrt{(x_{\text{goal}} - x_n)^2 + (y_{\text{goal}} - y_n)^2}
\]
(với $h(n)$ bằng $h(x)$, $x_n$ bằng $x$, $y_n = y$)

\begin{itemize}
  \item Trong bối cảnh tổng quát của BIT$^*$, chi phí ước lượng của một nút hoặc cạnh được kết hợp với chi phí thực tế đã biết từ điểm bắt đầu. Tổng chi phí ước lượng của một đỉnh $x$ là:
  \[
  f(x) = g(x) + h(x)
  \]
  trong đó $g(x)$ là chi phí thực tế từ $x_{\text{start}}$ đến $x$.
\end{itemize}

\section*{4. Lấy mẫu có thông tin}

Kỹ thuật lấy mẫu có thông tin tập trung việc lấy mẫu vào một vùng không gian hẹp hơn, cụ thể là bên trong một hình ellipsoid, sau khi một đường đi khả thi đầu tiên được tìm thấy. Vùng ellipsoid này được định nghĩa bởi điểm bắt đầu, điểm đích và chi phí của đường đi tốt nhất hiện tại ($c_{\text{best}}$). Mục đích là chỉ lấy mẫu ở những vị trí có khả năng cải thiện giải pháp hiện tại, loại bỏ các vùng không gian không cần thiết và tăng hiệu quả hội tụ đến nghiệm tối ưu.

\textbf{Công thức:} Các điểm mẫu được lấy sao cho tổng khoảng cách từ điểm mẫu đến điểm bắt đầu và điểm đích nhỏ hơn hoặc bằng $c_{\text{best}}$:
\[
\|x - x_{\text{start}}\| + \|x - x_{\text{goal}}\| \leq c_{\text{best}}
\]

\textbf{Trong đó:}
\begin{itemize}
  \item $c_{\text{best}}$: Chi phí của đường đi tốt nhất hiện tại.
  \item $\|\cdot\|$: Ký hiệu cho chuẩn Euclid.
\end{itemize}

\section*{5. Cắt tỉa (Pruning)}

\textbf{Mô tả và ý nghĩa:} Cắt tỉa là quá trình loại bỏ các đỉnh và cạnh trong cây tìm kiếm cũng như các điểm mẫu không còn khả năng cải thiện chi phí của đường đi tốt nhất hiện tại ($c_{\text{best}}$). Điều này giúp giảm kích thước của cây và tập mẫu, tập trung tài nguyên tính toán vào các khu vực có tiềm năng tìm thấy đường đi tốt hơn.

\textbf{Công thức:} Một đỉnh $x$ hoặc một mẫu $x$ sẽ bị cắt tỉa nếu thỏa mãn điều kiện:
\[
g(x) + h(x) \geq c_{\text{best}}
\]

\textbf{Trong đó:}
\begin{itemize}
  \item $g(x)$: Chi phí thực tế từ $x_{\text{start}}$ đến điểm $x$.
  \item $h(x)$: Chi phí ước lượng từ điểm $x$ đến $x_{\text{goal}}$ (heuristic).
  \item $c_{\text{best}}$: Chi phí của đường đi tốt nhất hiện tại.
\end{itemize}

\section*{6. Kết nối lại (Rewiring)}

\begin{itemize}
  \item Kết nối lại là một bước trong thuật toán BIT* (kế thừa từ RRT*) nhằm tối ưu hóa cấu trúc của cây tìm kiếm. Khi một đỉnh mới $x_{\text{new}}$ được thêm vào cây hoặc chi phí đến một đỉnh thay đổi, thuật toán kiểm tra các đỉnh lân cận ($x_{\text{neighbor}}$) của $x_{\text{new}}$ để xem liệu việc thay đổi cha của $x_{\text{neighbor}}$ thành $x_{\text{new}}$ có tạo ra một đường đi từ gốc đến $x_{\text{neighbor}}$ có chi phí thấp hơn hay không. Nếu có và đường đi mới không có va chạm, cây sẽ được cập nhật bằng cách thay đổi cạnh nối đến $x_{\text{neighbor}}$.
  
  \item \textbf{Công thức:} Chi phí đến một đỉnh $x_{\text{new}}$ thông qua một đỉnh lân cận $x_{\text{near}}$ được tính và so sánh với chi phí hiện tại đến $x_{\text{new}}$:
\end{itemize}

\begin{center}
  \textbf{Công thức Rewiring:}
  \[
  \text{cost}(x_{\text{new}}) = \min \left\{ \text{cost}(x_{\text{near}}) + c(x_{\text{near}}, x_{\text{new}}) \right\}
  \]
\end{center}

\textbf{Giải thích:}
\begin{itemize}
  \item $x_{\text{new}}$: điểm mới muốn thêm vào cây.
  \item $x_{\text{near}}$: các điểm “gần” trong cây hiện tại.
  \item $c(x_{\text{near}}, x_{\text{new}})$: chi phí từ $x_{\text{near}}$ đến $x_{\text{new}}$.
  \item $\text{cost}(x_{\text{new}})$: tổng chi phí tốt nhất từ gốc đến $x_{\text{new}}$.
\end{itemize}


 \chapter{Thuật toán BIT* }
\section{Ý tưởng chính của BIT*}

BIT* (Batch Informed Trees*) là một thuật toán lập kế hoạch chuyển động tối ưu, kết hợp giữa:

\begin{itemize}
    \item \textbf{RRT*}: khả năng tìm đường trong không gian lớn và hội tụ về lời giải tối ưu theo thời gian.
    \item \textbf{A*}: sử dụng heuristic (ước lượng chi phí) để hướng dẫn việc mở rộng cây theo hướng ưu tiên.
\end{itemize}

\textbf{Ý tưởng chính:}
\begin{itemize}
    \item Lấy mẫu ngẫu nhiên theo lô (\textit{batch sampling}) thay vì từng điểm một.
    \item Chỉ tập trung vào vùng có khả năng cải thiện lời giải hiện tại.
    \item Duyệt các đỉnh và cạnh theo chi phí dự kiến $f = g + h$ như trong A*.
\end{itemize}

\section{Các bước của thuật toán BIT*}

\subsection*{Khởi tạo:}
\begin{itemize}
    \item Tạo cây tìm đường chứa đỉnh xuất phát.
    \item Đặt chi phí tốt nhất hiện tại $c_{best} = \infty$.
    \item Khởi tạo hàng đợi ưu tiên.
\end{itemize}

\subsection*{Lặp lại cho đến khi hết thời gian hoặc hội tụ:}

\begin{enumerate}
    \item Nếu hàng đợi rỗng:
    \begin{itemize}
        \item Tạo lô mẫu mới trong không gian cấu hình.
        \item Lọc các mẫu có $f(x) = g(x) + h(x) < c_{best}$.
        \item Thêm các mẫu vào tập đỉnh chưa mở rộng.
        \item Cập nhật danh sách cạnh khả thi.
    \end{itemize}

    \item Trong khi hàng đợi chưa rỗng:
    \begin{itemize}
        \item Lấy cạnh có chi phí nhỏ nhất từ hàng đợi.
        \item Nếu $g(v) + h(x) > c_{best}$: bỏ qua cạnh.
        \item Nếu $x$ chưa có trong cây:
        \begin{itemize}
            \item Thêm đỉnh $x$ vào cây qua cạnh tốt nhất $(v, x)$.
            \item Nếu $x$ là đích $\rightarrow$ cập nhật $c_{best}$.
        \end{itemize}
    \end{itemize}
\end{enumerate}

\subsection*{Kết thúc:}
Trả về đường đi ngắn nhất tìm được.

\section{Giải thích thuật toán}

\begin{itemize}
    \item \textbf{Batch sampling} giúp duyệt không gian hiệu quả hơn so với RRT*.
    \item BIT* giống A* hoạt động trên không gian liên tục, kết hợp với cấu trúc cây của RRT.
    \item Thay vì mở rộng tất cả điểm như PRM hay RRT*, BIT* chỉ mở rộng những điểm có tiềm năng cải thiện lời giải hiện tại.
    \item Sau khi có lời giải đầu tiên, BIT* tiếp tục cải thiện, hội tụ dần về tối ưu.
\end{itemize}

\section{ Mối quan hệ với các thuật toán khác}

\begin{center}
\begin{tabular}{|c|m{10cm}|}
\hline
\textbf{Thuật toán} & \textbf{Mối quan hệ với BIT*} \\
\hline
\textbf{RRT*} & BIT* kế thừa khung cây mở rộng từ RRT* và đảm bảo hội tụ tối ưu. Tuy nhiên, BIT* mở rộng theo batch và có hướng dẫn heuristic. \\
\hline
\textbf{A*} & BIT* mượn chiến lược duyệt đỉnh theo chi phí $f = g + h$, ưu tiên mở rộng đỉnh hứa hẹn hơn, giúp nhanh hội tụ hơn. \\
\hline
\textbf{PRM*} & PRM* xây dựng đồ thị toàn cục trước rồi mới tìm đường. BIT* duyệt theo từng batch, hiệu quả hơn trong môi trường phức tạp. \\
\hline
\textbf{FMT*} & FMT* cũng duyệt theo chi phí như A*, nhưng BIT* sử dụng hàng đợi ưu tiên và mở rộng đỉnh linh hoạt hơn. \\
\hline
\end{tabular}
\end{center}

\chapter{Các mã giả code, kèm link code Python và demo }
\section*{Link code:}
\url{https://github.com/nvbangg/TRR2_BITstar/blob/main/Nh%C3%B3m%2014.3/BITstar.py}

\begin{center}
      \includegraphics[width= 1\textwidth]{anh1.1.png}
        \includegraphics[width= 1\textwidth]{anh1.2.png}
        \includegraphics[width= 1\textwidth]{anh1.3.png}
         \includegraphics[width= 1\textwidth]{anh1.4.png}
        \includegraphics[width= 1\textwidth]{anh1.5.png}
        \includegraphics[width= 1\textwidth]{anh1.6.png}
        \includegraphics[width= 1\textwidth]{anh1.7.png}
        \includegraphics[width= 1\textwidth]{anh1.8.png}
    \includegraphics[width= 1\textwidth]{anh1.9.png}
    \includegraphics[width= 1\textwidth]{anh2.0.png}
    \includegraphics[width= 1\textwidth]{anh2.1.png}
    \includegraphics[width= 1\textwidth]{anh2.2.png}
\end{center}




\section*{Demo video:}

\url{https://www.youtube.com/watch?v=sq4HM6zaMdQ}

\section*{Mã giả:}
\begin{algorithm}
\caption{Thuật toán mở rộng đồ thị tìm đường đi tối ưu}
\begin{algorithmic}[1]
\State Khởi tạo tập đỉnh $V \gets \{X_{\text{start}}\}$; $E \gets \emptyset$; $T \gets (V, E)$
\State $X_{\text{unconn}} \gets X_{\text{goal}}$ \Comment{Tạo mẫu rỗng}
\State $QV \gets V$; $QE \gets \emptyset$
\State $V_{\text{sol'n}} \gets V \cap \{X_{\text{goal}}\}$; $V_{\text{unexpnd}} \gets V$
\State $X_{\text{new}} \gets X_{\text{unconn}}$
\State $V_{\text{open}} \gets V \cup \{X_{\text{goal}}\}$
\State $V_{\text{expanded}} \gets V$
\State $c_i \gets \min_{v_{\text{goal}} \in V_{\text{sol'n}}} \{g_T(v_{\text{goal}})\}$

\While{không dừng}
    \If{$QE = \emptyset$ \textbf{và} $QV = \emptyset$}
        \State $X_{\text{reuse}} \gets \text{Prune}(T, X_{\text{unconn}}, c_i)$
        \State $X_{\text{sampling}} \gets \text{Sample}(m, X_{\text{start}}, X_{\text{goal}}, c_i)$
        \State $X_{\text{new}} \gets X_{\text{reuse}} \cup X_{\text{sampling}}$
        \State $X_{\text{unconn}} \gets X_{\text{unconn}} \cup X_{\text{new}}$
        \State $QV \gets V$
    \EndIf

    \While{BestQueueValue($QV$) $\leq$ BestQueueValue($QE$)}
        \State \text{ExpandNextVertex}($QV$, $QE$, $c_i$)
    \EndWhile

    \State $(v_{\min}, x_{\min}) \gets \text{popBestInQueue}(QE)$

    \If{không va chạm $(v_{\min}, x_{\min})$ \textbf{và} $g_T(v_{\min}) + c(v_{\min}, x_{\min}) + \hat{h}(x_{\min}) < c_i$}
        \State $c_{\text{edge}} \gets c(v_{\min}, x_{\min})$
        \If{$g_T(v_{\min}) + c_{\text{edge}} + \hat{h}(x_{\min}) < c_i$}
            \If{$g_T(v_{\min}) + c_{\text{edge}} < g_T(x_{\min})$}
                \If{$x_{\min} \in V$}
                    \State \text{Cập nhật cạnh cha mới, xóa cạnh cũ}
                    \State $E \gets \text{parent}(x_{\min})$
                \Else
                    \State $X_{\text{unconn}} \gets X_{\text{unconn}} \setminus \{x_{\min}\}$
                    \State $V \gets V \cup \{x_{\min}\}$
                    \State $QV \gets QV \cup \{x_{\min}\}$
                    \State $V_{\text{unexpnd}} \gets V_{\text{unexpnd}} \cup \{x_{\min}\}$
                \EndIf
                \If{$x_{\min} \in X_{\text{goal}}$}
                    \State $V_{\text{sol'n}} \gets V_{\text{sol'n}} \cup \{x_{\min}\}$
                \EndIf
                \State $E \gets E \cup \{(v_{\min}, x_{\min})\}$
                \State $c_i \gets \min_{v_{\text{goal}} \in V_{\text{sol'n}}} \{g_T(v_{\text{goal}})\}$
            \Else
                \State $QE \gets \emptyset$; $QV \gets \emptyset$
            \EndIf
        \EndIf
    \EndIf
\EndWhile

\State \Return $T$
\end{algorithmic}
\end{algorithm}


\











\chapter{So sánh và đánh giá}

\section*{So sánh}

Dựa trên kết quả thực nghiệm, có thể rút ra các so sánh chính sau:

\subsection*{BIT* vs RRT và các biến thể (Informed RRT*, RRT\#, SORRT*)}

\begin{itemize}
    \item \textbf{Tốc độ hội tụ và chất lượng giải pháp:} BIT* thường hội tụ nhanh hơn và đạt được giải pháp có chi phí thấp hơn trong cùng một khoảng thời gian, đặc biệt rõ rệt ở số chiều cao. Điều này là do BIT* sử dụng heuristic để sắp xếp thứ tự tìm kiếm một cách hiệu quả (giống A*) và xử lý mẫu theo lô, thay vì tìm kiếm ngẫu nhiên như RRT*. Informed RRT* và SORRT* cố gắng cải thiện RRT* bằng cách tập trung lấy mẫu hoặc sắp xếp mẫu, nhưng BIT* với việc xem xét nhiều kết nối trên đồ thị ẩn RGG tỏ ra hiệu quả hơn trong các bài toán phức tạp.
    \item \textbf{Thời gian giải pháp ban đầu:} BIT* có thể mất nhiều thời gian hơn một chút để tìm giải pháp ban đầu so với RRT* trong một số trường hợp đơn giản (do chi phí quản lý lô và hàng đợi), nhưng thường nhanh hơn trong các bài toán phức tạp hoặc số chiều cao nhờ tìm kiếm có hướng.
    \item \textbf{Khả năng mở rộng:} BIT* thể hiện khả năng mở rộng tốt hơn RRT* khi số chiều tăng lên.
\end{itemize}

\subsection*{BIT* vs FMT*}

\begin{itemize}
    \item \textbf{Tính Anytime:} BIT* là thuật toán anytime, liên tục cải thiện giải pháp theo thời gian, trong khi FMT* thì không (chỉ trả về giải pháp khi hoàn thành tìm kiếm trên số mẫu cố định).
    \item \textbf{Hiệu quả tìm kiếm:} Cả hai đều sử dụng tìm kiếm có thứ tự trên tập mẫu. FMT* tìm kiếm theo chi phí đến (cost-to-come), còn BIT* tìm kiếm theo chi phí giải pháp ước tính (giống A*). BIT* có thể hiệu quả hơn nhờ heuristic và khả năng tái sử dụng thông tin giữa các lô.
    \item \textbf{Chất lượng giải pháp:} Với cùng số lượng mẫu hoặc thời gian tính toán tương đương, BIT* thường cho kết quả cuối cùng tốt hơn hoặc tương đương FMT* nhờ khả năng cải thiện liên tục và tập trung vào vùng informed set.
\end{itemize}

\subsection*{BIT* vs RRT-Connect}

\begin{itemize}
    \item \textbf{Tốc độ vs. Tối ưu:} RRT-Connect thường là thuật toán nhanh nhất tìm ra một giải pháp khả thi ban đầu do tìm kiếm hai chiều. Tuy nhiên, giải pháp này thường xa tối ưu và không được cải thiện. BIT* tuy có thể chậm hơn một chút ban đầu nhưng đảm bảo hội tụ về giải pháp tối ưu và liên tục cải thiện chất lượng. Trong nhiều trường hợp phức tạp (ví dụ: HERB 14-DOF), BIT* thậm chí còn nhanh hơn RRT-Connect để tìm giải pháp ban đầu.
\end{itemize}

\subsection*{Ảnh hưởng của kích thước lô trong BIT*}

\begin{itemize}
    \item Kích thước lô nhỏ (ví dụ: $m = 1$) làm BIT* hoạt động giống Informed RRT*.
    \item Kích thước lô lớn làm BIT* hoạt động giống FMT* hơn (nếu chỉ chạy 1 lô).
    \item Kích thước lô trung bình (ví dụ: $m = 100$) dường như mang lại sự cân bằng tốt giữa tốc độ tìm giải pháp ban đầu và tốc độ hội tụ (Hình 16 trong~\cite{ref11}). Việc giảm kích thước lô có thể giảm thời gian tìm giải pháp ban đầu đến một ngưỡng nhất định nhưng cũng có thể làm chậm tốc độ hội tụ, đặc biệt ở số chiều cao.
\end{itemize}

\section*{Đánh giá}

BIT* nổi lên như một thuật toán lập kế hoạch đường đi mạnh mẽ, kết hợp thành công các ưu điểm của phương pháp dựa trên tìm kiếm đồ thị (có thứ tự, hiệu quả) và phương pháp dựa trên lấy mẫu (anytime, tối ưu tiệm cận, khả năng mở rộng).

\subsection*{Ưu điểm của BIT*}

\begin{itemize}
    \item \textbf{Tối ưu tiệm cận và hoàn chỉnh xác suất:} Đảm bảo về mặt lý thuyết sẽ hội tụ đến giải pháp tối ưu nếu tồn tại.
    \item \textbf{Hiệu suất Anytime:} Nhanh chóng tìm ra giải pháp khả thi và liên tục cải thiện chất lượng theo thời gian, phù hợp cho các ứng dụng có giới hạn thời gian.
    \item \textbf{Tìm kiếm có thông tin và hiệu quả:} Việc sử dụng heuristic và tập trung lấy mẫu vào vùng informed set giúp BIT* tìm kiếm hiệu quả hơn nhiều so với tìm kiếm ngẫu nhiên của RRT*, đặc biệt trong không gian trạng thái phức tạp và số chiều cao. Nó tránh lãng phí tài nguyên vào các vùng không gian không hứa hẹn.
    \item \textbf{Xử lý theo lô và tái sử dụng thông tin:} Cho phép tìm kiếm có thứ tự trên không gian liên tục và tái sử dụng thông tin từ các lô trước, tăng tốc độ hội tụ.
    \item \textbf{Khả năng mở rộng tốt:} Các thí nghiệm cho thấy BIT* hoạt động tốt hơn các thuật toán khác khi số chiều của không gian trạng thái tăng lên.
    \item \textbf{Ít nhạy cảm với tham số:} So với RRT* (phụ thuộc nhiều vào độ dài cạnh tối đa), BIT* (với kích thước lô $m=100$) tỏ ra ổn định trên nhiều loại bài toán~\cite{ref11}.
\end{itemize}

\subsection*{Nhược điểm của BIT*}

\begin{itemize}
    \item \textbf{Độ phức tạp:} BIT* phức tạp hơn trong việc triển khai so với RRT* do quản lý hai hàng đợi, xử lý lô và các cơ chế tỉa cây, đánh dấu trạng thái.
    \item \textbf{Ảnh hưởng của Heuristic:} Hiệu suất của BIT* phụ thuộc vào chất lượng của hàm heuristic. Một heuristic tốt sẽ giúp hội tụ nhanh hơn, nhưng một heuristic kém có thể không mang lại nhiều lợi ích so với tìm kiếm không có thông tin. Tuy nhiên, ngay cả với heuristic zero (tương đương Dijkstra), BIT* vẫn hoạt động.
    \item \textbf{Chi phí quản lý lô:} Việc xử lý mẫu theo lô và cập nhật hàng đợi có thể tạo ra chi phí tính toán nhất định, có thể làm chậm thời gian tìm giải pháp ban đầu trong các bài toán rất đơn giản so với RRT*.
    \item \textbf{Kết nối cạnh:} BIT* xem xét nhiều kết nối tiềm năng cho mỗi mẫu trong RGG ẩn. Điều này giúp tìm ra đường đi tốt hơn nhưng cũng có thể tốn chi phí nếu nhiều kết nối bị chặn bởi chướng ngại vật. Các biến thể như SORRT* hoặc cơ chế loại bỏ mẫu (sample removal) có thể giảm bớt vấn đề này nhưng có thể ảnh hưởng đến việc khai thác các mẫu hữu ích.
\end{itemize}









\chapter{Ứng dụng }
\section*{Ứng dụng của BIT*}

\begin{itemize}
    \item \textbf{Tìm đường đi tối ưu trong đồ thị có trọng số:}  
    BIT* có thể áp dụng để tìm đường ngắn nhất có ràng buộc, tương tự như Dijkstra hoặc A*, nhưng hiệu quả hơn khi không gian trạng thái lớn nhờ kết hợp heuristic và sampling.

    \item \textbf{Tối ưu bài toán rời rạc có không gian trạng thái lớn:}  
    BIT* sử dụng heuristic và sampling có định hướng để tìm nghiệm gần tối ưu cho các bài toán như lập lịch, phân công tài nguyên, routing trong mạng.

    \item \textbf{Mô hình hóa bài toán điều khiển rời rạc:}  
    BIT* giúp tìm đường đi cho robot hoặc hệ thống trong không gian lưới, tránh chướng ngại vật và tối ưu chi phí di chuyển.

    \item \textbf{Giảng dạy kỹ thuật heuristic và cấu trúc dữ liệu:}  
    BIT* là ví dụ minh họa rõ ràng cho việc kết hợp hàng đợi ưu tiên, heuristic, và cập nhật động trong các bài toán tổ hợp.
\end{itemize}

\section*{Kết luận}

BIT* là một bước tiến quan trọng trong lĩnh vực lập kế hoạch đường đi dựa trên lấy mẫu.  
Bằng cách tích hợp tìm kiếm có hướng heuristic vào một quy trình xử lý mẫu theo lô và tính chất \textit{anytime}, BIT* cung cấp sự cân bằng tuyệt vời giữa tốc độ hội tụ, chất lượng giải pháp và khả năng mở rộng.

Thuật toán này đặc biệt phù hợp cho các bài toán lập kế hoạch phức tạp, có số chiều cao trong robotics, nơi việc tìm kiếm đường đi tối ưu hoặc gần tối ưu một cách nhanh chóng là rất quan trọng. Các kết quả thực nghiệm trên cả môi trường mô phỏng và hệ thống robot thực tế đã chứng minh tính ưu việt của BIT* so với nhiều thuật toán tiên tiến khác.



\begin{thebibliography}{30}
\addcontentsline{toc}{chapter}{\vspace*{-8pt} Tài liệu tham khảo}

\section*{Bài báo gốc về BIT*}

\begin{itemize}
    \item \textbf{Tên bài:} \textit{"Batch Informed Trees (BIT*): Sampling-based Optimal Planning via the Heuristically Guided Search of Implicit Random Geometric Graphs"}
    \item \textbf{Tác giả:} Jonathan D. Gammell, Siddhartha S. Srinivasa, Timothy D. Barfoot
    \item \textbf{Năm:} 2015
    \item \textbf{Link:} \href{https://arxiv.org/abs/1405.5848}{https://arxiv.org/abs/1405.5848}
\end{itemize}

Đây là tài liệu \textbf{quan trọng nhất}, trình bày đầy đủ ý tưởng, phân tích và so sánh BIT* với các thuật toán khác.

\section*{Sách tham khảo}

\begin{itemize}[label=\textcolor{blue}{\textbullet}]
    \item \textbf{\textit{Planning Algorithms} – Steven M. LaValle}
    
    \begin{itemize}
        \item Một cuốn sách \textbf{kinh điển}, bao quát nhiều chủ đề về lập kế hoạch chuyển động: motion planning, discrete planning, planning under uncertainty,...
        \item \textbf{Link tải miễn phí} (tác giả cung cấp): \href{http://lavalle.pl/planning/}{http://lavalle.pl/planning/}
    \end{itemize}
\end{itemize}

\section*{Khóa học và bài giảng online}

\begin{itemize}[label=\textcolor{blue}{\textbullet}]
    \item \textbf{\textit{CS287: Advanced Robotics – UC Berkeley}}
    \begin{itemize}
        \item Giảng viên: Pieter Abbeel
        \item Có bài giảng video về sampling-based planning và trajectory optimization.
        \item YouTube playlist: \href{https://www.youtube.com/playlist?list=PLkFD6_40KJIwhWJpGazJ9VSj9CFMkb79A}{https://www.youtube.com/playlist?list=PLkFD6\_40KJIwhWJpGazJ9VSj9CFMkb79A}
    \end{itemize}
\end{itemize}

\end{thebibliography} 
\end{document}
 
